<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Direct Message</title>
<style>
  :root{--panel:#1b1b1b;--muted:#a9adb4;--accent:#2a6}
  body{margin:0;background:#111;color:#eee;font-family:Arial,Helvetica,sans-serif}
  a{color:#9ecbff;text-decoration:none}
  .wrap{max-width:900px;margin:0 auto;padding:24px}
  .card{background:var(--panel);border-radius:12px;padding:12px}
  .muted{color:var(--muted)}
  .msgs{display:flex;flex-direction:column;gap:10px;max-height:60vh;overflow:auto;padding:8px}
  .row{display:flex;gap:8px;align-items:flex-end}
  .bubble{max-width:70%;padding:10px 12px;border-radius:12px;background:#222;white-space:pre-wrap}
  .mine .bubble{background:#2a2a2a;border:1px solid #333}
  .meta{font-size:12px;opacity:.7;margin-left:6px}
  .compose{display:grid;grid-template-columns:1fr auto;gap:10px;margin-top:10px}
  textarea{min-height:70px;padding:10px;border-radius:10px;border:1px solid #333;background:#222;color:#eee}
  button{padding:10px 14px;border:none;border-radius:10px;background:var(--accent);color:#fff;cursor:pointer}
</style>
</head>
<body>
<app-menu></app-menu>
<script type="module" src="/menu.js"></script>

<div class="wrap">
  <a href="messages.html">← Back to Messages</a>
  <div class="card" style="margin-top:10px">
    <div id="head" class="muted">Loading…</div>
  </div>

  <div class="card" style="margin-top:12px">
    <div id="list" class="msgs"></div>
    <div class="compose">
      <textarea id="text" placeholder="Write a message…"></textarea>
      <button id="send">Send</button>
    </div>
    <div id="status" class="muted" style="margin-top:6px"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
const sb = supabase.createClient(
  'https://wktxpukjmvmhzpctttjx.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndrdHhwdWtqbXZtaHpwY3R0dGp4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMjg2MjAsImV4cCI6MjA3MTcwNDYyMH0.07xzRjb_iQlkaObfslKiL9VZIHT8P3vnK-ZkIVm2qVY'
);

const qs = new URLSearchParams(location.search);
const threadId = qs.get('id');

let me = null, other = null, otherLastRead = null, channel = null;

document.getElementById('send').addEventListener('click', sendMsg);
document.getElementById('text').addEventListener('keydown', e=>{
  if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); sendMsg(); }
});

window.addEventListener('beforeunload', ()=>{ if(channel) sb.removeChannel(channel); });
document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible') markRead(); });

(async function init(){
  if (!threadId){ location.href='messages.html'; return; }
  const { data:{ session } } = await sb.auth.getSession();
  if (!session){ location.href='login.html?next=' + encodeURIComponent('dm.html?id='+threadId); return; }
  me = session.user;

  const { data: parts, error } = await sb
    .from('dm_participants')
    .select('user_id,last_read_at, profiles:user_id(username,avatar_url)')
    .eq('thread_id', threadId);
  if (error || !parts?.length){ document.getElementById('head').textContent='Thread not found.'; return; }
  if (!parts.some(p=>p.user_id===me.id)){ document.getElementById('head').textContent='Access denied.'; return; }

  const otherPart = parts.find(p=>p.user_id!==me.id);
  other = otherPart?.profiles || { username:'user' };
  otherLastRead = otherPart?.last_read_at ? new Date(otherPart.last_read_at) : null;

  document.getElementById('head').innerHTML =
    `Chat with <a href="user.html?u=${encodeURIComponent(other.username)}">@${other.username}</a>`;

  await loadMessages();
  await markRead();
  subscribeRealtime();
})();

async function loadMessages(){
  const list = document.getElementById('list');
  const { data: msgs, error } = await sb
    .from('dm_messages')
    .select('id,author_id,body,created_at')
    .eq('thread_id', threadId)
    .order('created_at',{ascending:true});
  if (error){ document.getElementById('status').textContent='Error: '+error.message; return; }

  list.innerHTML = (msgs||[]).map(m => renderMsg(m)).join('');
  list.scrollTop = list.scrollHeight;
}

function renderMsg(m){
  const mine = m.author_id === me.id;
  let metaText;

  if (mine){
    // "Read" if the other user's last_read_at is after this message
    metaText = otherLastRead && new Date(otherLastRead) > new Date(m.created_at)
      ? 'Read'
      : 'Sent';
  } else {
    // Messages from them show "Unread" until you open
    metaText = 'Unread';
  }

  return `
    <div class="row ${mine?'mine':''}" data-mid="${m.id}">
      <div class="bubble">${escapeHtml(m.body)}</div>
      <div class="meta">${metaText}</div>
    </div>
  `;
}

function updateReadReceipts(){
  const list = document.getElementById('list');
  list.querySelectorAll('.row.mine').forEach(row=>{
    const ts = row.dataset.time ? new Date(row.dataset.time) : null;
    const meta = row.querySelector('.meta');
    if (meta && otherLastRead && ts && otherLastRead > ts){
      meta.textContent = 'Read';
    }
  });
}

function appendMessage(m){
  const list = document.getElementById('list');
  const nearBottom = (list.scrollHeight - list.scrollTop - list.clientHeight) < 60;
  const mine = m.author_id === me.id;
  const el = document.createElement('div');
  el.className = 'row ' + (mine?'mine':'');
  el.dataset.mid = m.id;
  el.dataset.time = m.created_at;
  el.innerHTML = `
    <div class="bubble">${escapeHtml(m.body)}</div>
    <div class="meta">${mine?'Sent':'Unread'}</div>
  `;
  list.appendChild(el);
  if (nearBottom) list.scrollTop = list.scrollHeight;
}

function subscribeRealtime(){
  if (channel) sb.removeChannel(channel);

  channel = sb.channel('dm_'+threadId)
    // Listen for new messages
    .on('postgres_changes', { event:'INSERT', schema:'public', table:'dm_messages', filter:'thread_id=eq.'+threadId },
      (payload)=>{
        const m = payload.new;
        if (document.querySelector(`.row[data-mid="${m.id}"]`)) return;
        appendMessage(m);
        if (m.author_id !== me.id) markRead();
      })
    // Listen for read receipts
    .on('postgres_changes', { event:'UPDATE', schema:'public', table:'dm_participants', filter:'thread_id=eq.'+threadId },
      (payload)=>{
        const updated = payload.new;
        if (updated.user_id !== me.id){ // other user updated their read time
          otherLastRead = updated.last_read_at ? new Date(updated.last_read_at) : null;
          updateReadReceipts();
        }
      })
    .subscribe();
}

async function sendMsg(){
  const box = document.getElementById('text');
  const text = (box.value||'').trim();
  if (!text) return;

  const list = document.getElementById('list');
  const nearBottom = (list.scrollHeight - list.scrollTop - list.clientHeight) < 60;

  const tempId = 'tmp_'+Date.now()+'_'+Math.random().toString(36).slice(2);
  const el = document.createElement('div');
  el.className = 'row mine';
  el.dataset.mid = tempId;
  el.dataset.time = new Date().toISOString();
  el.innerHTML = `
    <div class="bubble">${escapeHtml(text)}</div>
    <div class="meta">Sent</div>
  `;
  list.appendChild(el);
  if (nearBottom) list.scrollTop = list.scrollHeight;

  const { error } = await sb
    .from('dm_messages')
    .insert({ thread_id: threadId, author_id: me.id, body: text }, { returning:'minimal' });
  if (error){
    el.querySelector('.meta').textContent = 'Failed';
    el.querySelector('.bubble').style.opacity = 0.6;
  }
  box.value='';
}

async function markRead(){
  await sb.from('dm_participants')
    .update({ last_read_at: new Date().toISOString() })
    .eq('thread_id', threadId)
    .eq('user_id', me.id);
}

function escapeHtml(s){
  return String(s||'').replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
}
</script>
</body>
</html>
