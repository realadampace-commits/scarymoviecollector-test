<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Messages</title>
<style>
  :root{--panel:#1b1b1b;--muted:#a9adb4;--ink:#eee;--accent:#2a6}
  body{margin:0;background:#111;color:var(--ink);font-family:Arial,Helvetica,sans-serif}
  a{color:#9ecbff;text-decoration:none}
  .wrap{max-width:1000px;margin:0 auto;padding:24px}
  .grid{display:grid;grid-template-columns:320px 1fr;gap:16px}
  .card{background:var(--panel);border-radius:12px;padding:12px}
  .muted{color:var(--muted)}
  .thread{display:flex;gap:10px;align-items:center;padding:10px;border-radius:10px;cursor:pointer}
  .thread:hover{background:#222}
  .ava{width:36px;height:36px;border-radius:50%;overflow:hidden;background:#333;flex:0 0 auto}
  .ava img{width:100%;height:100%;object-fit:cover}
  .title{display:flex;align-items:center;gap:6px}
  .unread{background:#dc143c;color:#fff;border-radius:999px;padding:0 6px;font-size:12px}
  .row{display:flex;gap:8px;align-items:center}
  input,button{padding:10px;border-radius:8px;border:1px solid #333;background:#222;color:#eee}
  button{background:var(--accent);border:none;cursor:pointer}
  .preview{opacity:.85;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
</style>
</head>
<body>
<app-menu></app-menu>
<script type="module" src="/menu.js"></script>

<div class="wrap">
  <a href="index.html">← Home</a>
  <h2>Messages</h2>

  <div class="card" style="margin-bottom:12px">
    <div class="row">
      <input id="userSearch" placeholder="Start new chat with @username"/>
      <button id="startBtn">Start</button>
      <span id="startMsg" class="muted"></span>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3 style="margin:0 0 8px">Inbox</h3>
      <div id="list" style="display:grid;gap:6px"></div>
      <div id="status" class="muted" style="margin-top:8px"></div>
    </div>
    <div class="card">
      <div id="preview" class="muted">Select a conversation.</div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
const sb = supabase.createClient(
  'https://wktxpukjmvmhzpctttjx.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndrdHhwdWtqbXZtaHpwY3R0dGp4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMjg2MjAsImV4cCI6MjA3MTcwNDYyMH0.07xzRjb_iQlkaObfslKiL9VZIHT8P3vnK-ZkIVm2qVY'
);

let me = null;
let realtimeChannel = null;   // keep the active channel so we can unsubscribe/re-subscribe

(async function init(){
  const { data:{ session } } = await sb.auth.getSession();
  if (!session){ location.href='login.html?next=messages.html'; return; }
  me = session.user;

  const threadIds = await loadInbox();        // initial render
  await subscribeInbox(threadIds);            // start realtime
})();

/** Renders the inbox and returns the array of my thread ids in newest->oldest order */
async function loadInbox(){
  const status = document.getElementById('status');
  const list   = document.getElementById('list');
  status.textContent = 'Loading…';

  // my participation rows, newest threads first
  const { data: parts, error } = await sb
    .from('dm_participants')
    .select('thread_id,last_read_at, dm_threads!inner(created_at), profiles:user_id(username,avatar_url)')
    .eq('user_id', me.id)
    .order('created_at', { ascending:false, foreignTable: 'dm_threads' });

  if (error){ status.textContent='Error: '+error.message; return []; }
  if (!parts?.length){ status.textContent='No conversations yet.'; list.innerHTML=''; return []; }

  const threadIds = [...new Set(parts.map(p=>p.thread_id))];

  // other participant per thread
  const { data: others } = await sb
    .from('dm_participants')
    .select('thread_id, profiles:user_id(username,avatar_url)')
    .in('thread_id', threadIds)
    .neq('user_id', me.id);
  const otherByThread = Object.fromEntries((others || []).map(o => [o.thread_id, o.profiles]));

  // latest message per thread (a small view that has thread_id, body, created_at)
  const { data: latest } = await sb.from('dm_latest')
    .select('*')
    .in('thread_id', threadIds);
  const latestByThread = Object.fromEntries((latest||[]).map(m=>[m.thread_id, m]));

  // map of my last_read_at for quick lookup
  const lastReadByThread = Object.fromEntries(parts.map(p => [p.thread_id, p.last_read_at]));

  // render
  list.innerHTML = parts.map(p=>{
    const m = latestByThread[p.thread_id];
    const other = otherByThread[p.thread_id];
    const preview = m?.body ? m.body : '(no messages yet)';
    const lastRead = lastReadByThread[p.thread_id] ? new Date(lastReadByThread[p.thread_id]) : null;
    const unread = m && (!lastRead || new Date(m.created_at) > lastRead);

    return `
      <div class="thread" data-id="${p.thread_id}">
        <span class="ava">${other?.avatar_url ? `<img src="${other.avatar_url}" alt="">` : ''}</span>
        <div style="flex:1">
          <div class="title">
            <strong>${other?.username ? '@'+other.username : 'Conversation'}</strong>
            ${unread ? '<span class="unread">new</span>' : ''}
          </div>
          <div class="preview">${escapeHtml(preview)}</div>
        </div>
      </div>
    `;
  }).join('');

  // open thread
  list.querySelectorAll('.thread').forEach(el=>{
    el.addEventListener('click',()=>{ location.href = 'dm.html?id=' + el.dataset.id; });
  });

  status.textContent = '';
  return threadIds;
}

/** Cleanly (re)subscribe to realtime events relevant to this user’s inbox */
async function subscribeInbox(threadIds){
  // close old channel if present
  if (realtimeChannel) {
    try { await sb.removeChannel(realtimeChannel); } catch(_) {}
    realtimeChannel = null;
  }

  // Build a filter for messages in *my* threads
  // Supabase realtime supports eq filters. For multiple threads, open one channel and filter client-side,
  // or build multiple .on registrations. Here we filter client-side for simplicity + reliability.
  const myThreadSet = new Set(threadIds);

  realtimeChannel = sb.channel(`dm_inbox_${me.id}_${Date.now()}`)
    // 1) New messages anywhere -> if message thread is mine, refresh inbox
    .on('postgres_changes',
      { event: 'INSERT', schema: 'public', table: 'dm_messages' },
      async (payload) => {
        const tid = payload.new?.thread_id;
        if (!tid) return;

        // Fast path: if this thread is already in my list, just refresh list UI
        if (myThreadSet.has(tid)) {
          await loadInbox();
          return;
        }

        // Slow path: maybe a brand-new conversation was started with me;
        // check if I'm a participant on this thread, then reload + resubscribe.
        const { data: mine } = await sb
          .from('dm_participants')
          .select('thread_id')
          .eq('thread_id', tid)
          .eq('user_id', me.id)
          .maybeSingle();
        if (mine) {
          const ids = await loadInbox();
          await subscribeInbox(ids); // re-subscribe so future messages in new thread stream in
        }
      })
    // 2) My read-state changed (last_read_at) -> update unread badge
    .on('postgres_changes',
      { event: 'UPDATE', schema: 'public', table: 'dm_participants', filter: `user_id=eq.${me.id}` },
      async () => { await loadInbox(); })
    // 3) Someone added me to a new thread (new conversation) -> reload + re-subscribe with new IDs
    .on('postgres_changes',
      { event: 'INSERT', schema: 'public', table: 'dm_participants', filter: `user_id=eq.${me.id}` },
      async () => {
        const ids = await loadInbox();
        await subscribeInbox(ids);
      })
    .subscribe();
}

// ---- helpers you already have ----
function escapeHtml(s){
  return String(s||'').replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
}
</script>
</body>
</html>
